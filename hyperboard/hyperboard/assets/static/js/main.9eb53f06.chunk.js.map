{"version":3,"sources":["request.js","index.js"],"names":["codeMessage","checkStatus","response","status","errortext","statusText","notification","error","message","url","description","Error","name","proxyRequest","options","checkResponseCode","prefix","newOptions","credentials","method","body","FormData","headers","Accept","JSON","stringify","sessionId","localStorage","getItem","language","fetch","then","r","json","e","code","data","jsonResponse","console","warn","request","startsWith","pathJoin","get","qsStringify","post","put","delete","experimentReducer","experimentVis","renderDatasetSummary","renderExperimentProcess","ActionType","log","StepStatus","info","experimentStore","steps","document","getElementById","send2store","event","dispatch","eventBegin","watchEventInterval","watchNewEvents","params","begin","toString","events","length","forEach","type","ExperimentBreak","ExperimentEnd","isExperimentFinishedEvent","clearInterval","experimentFinished","expState","ExperimentStart","payload","setInterval"],"mappings":"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","file":"static/js/main.9eb53f06.chunk.js","sourcesContent":["import { fetch } from 'dva';\n// import { router } from 'umi';\nimport { notification } from 'antd';\nimport { join as pathJoin } from 'path';\nimport { stringify as qsStringify } from 'qs';\n// import router from 'umi/router';\n\n// import './promise';\nconst apiPrefix = '';\n\nconst codeMessage = {\n  200: '服务器成功返回请求的数据。',\n  201: '新建或修改数据成功。',\n  202: '一个请求已经进入后台排队（异步任务）。',\n  204: '删除数据成功。',\n  400: '发出的请求有错误，服务器没有进行新建或修改数据的操作。',\n  401: '用户没有权限（令牌、用户名、密码错误）。',\n  403: '用户得到授权，但是访问是被禁止的。',\n  404: '发出的请求针对的是不存在的记录，服务器没有进行操作。',\n  406: '请求的格式不可得。',\n  410: '请求的资源被永久删除，且不会再得到的。',\n  422: '当创建一个对象时，发生一个验证错误。',\n  500: '服务器发生错误，请检查服务器。',\n  502: '网关错误。',\n  503: '服务不可用，服务器暂时过载或维护。',\n  504: '网关超时。',\n};\nfunction checkStatus(response) {\n  // console.log(response.headers.get('Date'));\n  if (response && response.status >= 200 && response.status < 300) {\n    return response;\n  }\n  const errortext = codeMessage[response.status] || response.statusText;\n  notification.error({\n    message: `请求错误 ${response.status}: ${response.url}`,\n    description: errortext,\n  });\n  const error = new Error(errortext);\n  error.name = response.status;\n  error.response = response;\n  throw error;\n}\n\n// function changeLoadingStatus(response, loadingId) {\n//   if (loadingId) {\n//     window.g_app._store.dispatch({\n//       type: 'loadingstatus/remove',\n//       payload: {\n//         loadingId,\n//       },\n//     });\n//   }\n//   return response;\n// }\n\n/**\n * Requests a URL, returning a promise.\n *\n * @param  {string} url       The URL we want to request\n * @param  {object} [options] The options we want to pass to \"fetch\"\n * @param  checkResponseCode 是否检查返回状态码，如果要求，则会检查相应的状态码，如果不对右侧通知，如果设置为false则不检查状态\n * @return {object}           An object containing either \"data\" or \"err\"\n */\nexport function request(url, options, checkResponseCode) {\n  const defaultOptions = {\n    credentials: 'include',\n  };\n  // const loadingId = options && options.body && options.body.loadingId;\n  const newOptions = { ...defaultOptions, ...options };\n  if (newOptions.method === 'POST' || newOptions.method === 'PUT' || newOptions.method === 'DELETE') {\n    if (!(newOptions.body instanceof FormData)) {\n      // if (typeof newOptions.body === 'object' && !Array.isArray(newOptions.body)) {\n      //   const { ...body } = newOptions.body;\n      //   delete body.loadingId;\n      //   newOptions.body = body;\n      // }\n      newOptions.headers = {\n        Accept: 'application/json, text/plain, */*',\n        'Content-Type': 'application/json; charset=utf-8',\n        ...newOptions.headers,\n      };\n      newOptions.body = JSON.stringify(newOptions.body);\n    } else {\n      // newOptions.body is FormData\n      newOptions.headers = {\n        Accept: 'application/json',\n        ...newOptions.headers,\n      };\n    }\n  }\n\n  //\n  newOptions.headers = {\n    ...newOptions.headers,\n    sessionId: localStorage.getItem('sessionId'),\n    language: localStorage.getItem('intlLang'),\n  };\n  return fetch(url, newOptions).then(checkStatus).then(r => {\n    try {\n      return r.json();\n    }catch (e){\n      // 如果请求不是一个json 将会报错\n      return {\n        code: -2,\n        data: {}\n      }\n    }\n  } ).then((jsonResponse) => {\n      if(checkResponseCode === true) {\n        if(jsonResponse.code !== 0){\n          // showNotification(JSON.stringify(jsonResponse));\n          console.warn(JSON.stringify(jsonResponse))\n        }\n      }\n      return jsonResponse;\n    })\n}\n\n/**\n *  the proxy of request\n * @param url\n * @param options\n * @returns {*}\n */\nfunction proxyRequest(url, options, checkResponseCode) {\n  options = options || {};\n  const prefix = options.prefix || apiPrefix;\n  url = url.startsWith(prefix) ? url : pathJoin(prefix, url);\n  return request(url, options, checkResponseCode);\n}\n\n/**\n * @param url\n * @param data   such as : {name = xxx ,age = xx } equel : url ? name=xxx&age=xx\n * @param options\n * @returns {*}\n */\nproxyRequest.get = (url, data, options, checkResponseCode=true) => {\n  options = options || {};\n  url = data ? `${url}?${qsStringify(data)}` : url;\n  return proxyRequest(url, options, checkResponseCode);\n};\n/**\n *\n * @param url\n * @param data\n * @param options\n * @returns {*}\n */\nproxyRequest.post = (url, data, options, checkResponseCode=true) => {\n  options = options || {};\n  options.body = data;\n  options.method = 'POST';\n  return proxyRequest(url, options, checkResponseCode);\n};\n\n/**\n *\n * @param url\n * @param data\n * @param options\n * @returns {*}\n */\nproxyRequest.put = (url, data, options, checkResponseCode=true) => {\n  options = options || {};\n  options.body = data || {};\n  options.method = 'PUT';\n  return proxyRequest(url, options, checkResponseCode);\n};\n\n/**\n *\n * @param url\n * @param data\n * @param options\n * @returns {*}\n */\nproxyRequest.delete = (url, data, options, checkResponseCode=true) => {\n  options = options || {};\n  options.body = data || {};\n  options.method = 'DELETE';\n  return proxyRequest(url, options, checkResponseCode);\n};\n\n/**\n * @param url\n * @param options\n * @returns {*}\n */\nexport default proxyRequest;\n","import  { experimentVis }  from \"hyperboard-frontend\";\nimport request from './request';\n\nconst { renderDatasetSummary, experimentReducer, renderExperimentProcess, ActionType, StepStatus } = experimentVis;\n\nconst log = console;\n\nlog.info(experimentReducer);\n\nconst experimentData = {\n    status: \"init\", //\n    steps: []\n}\n\nconst domElement = document.getElementById('root');\nconst experimentStore = renderExperimentProcess(experimentData, domElement)\n\nfunction send2store(event){\n    experimentStore.dispatch(event)\n}\n\nfunction isExperimentFinishedEvent(event){\n    const {type} = event;\n    return type === ActionType.ExperimentBreak || type === ActionType.ExperimentEnd\n}\n\nlet eventBegin = 0;\nlet watchEventInterval = null ;\n\nfunction watchNewEvents(){\n    const params = {begin: eventBegin};\n    request.get(`/api/events`, params).then(response => {\n        log.info(\"watchNewEvents begin event \"+ eventBegin.toString() + \", response\")\n        log.info(JSON.stringify(response))\n\n        const events = response.data.events ;\n        eventBegin = eventBegin + events.length;\n\n        events.forEach(event => {\n            // 往 store 里发送事件\n            send2store(event)\n\n            // check experiment whatever finished\n            if (isExperimentFinishedEvent(event)){\n                log.info(\"checked finished event, stop the interval, id: \" + watchEventInterval.toString())\n                if (watchEventInterval !== null){\n                    clearInterval(watchEventInterval)\n                }\n            }\n        });\n    })\n}\n\n// TODO: 处理后端服务已经停止的情况，实验中断或者被强行停止\nrequest.get(`/api/events`).then(response => {\n    console.info(\"response\");\n    console.info(response);\n\n    const data = response.data;\n    const { events } = data;\n    let experimentFinished = false;\n    // merge all events now\n    let expState = {}\n    events.forEach( event => {\n        expState = experimentReducer(expState, event)\n        const {type} = event;\n        if(type === ActionType.ExperimentBreak || type === ActionType.ExperimentEnd) {\n            experimentFinished = true;\n        }\n    });\n\n    // send to store\n    send2store(\n        {\n            type: ActionType.ExperimentStart,\n            payload: expState\n        }\n    )\n\n    // start interval to watch new events if experiment not finished\n    if (!experimentFinished){\n        eventBegin = events.length;\n        watchEventInterval = setInterval(watchNewEvents, 1000);\n        log.info(\"experiment not finished yet, start a interval to watch new event, interval id: \"\n            + watchEventInterval.toString() + \", current already received \" + eventBegin.toString() + \" events \")\n    }else{\n        log.info(\"checked experiment is finished on page start, do not start the watchNewEvent interval\")\n    }\n})\n\n\n"],"sourceRoot":""}